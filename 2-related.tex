
\chapter{関連研究}
本章では、本研究に関係する既存の研究や技術について述べる。

\section{XDR}
XDR\cite{rfc4506}は、オブジェクトシリアライズ手法の一つである。バイナリ形式の表現方法を用いるため、空間効率および処理速度に優れる。

XDRではシリアライズ対象となるオブジェクトの構造を記述するために、専用のインタフェース記述言語（IDL）を用いる。この記述から、Cの構造体の定義と、その構造体をシリアライズ・デシリアライズするプログラムが生成される。
このIDLの記述例を次に示す。

\begin{lstlisting}
struct echo_message {
    string str;
    int num;
};
\end{lstlisting}

struct echo\_messageは、文字列と整数を含んだ構造体の定義である。

XDRでは、シリアライズされたデータの中に元の構造体の型に関する情報は含まれていないため、IDLが無ければオブジェクトをデシリアライズすることができない。
また、XDRの処理系であるrpcgenはCのプログラムを生成することから、特別な工夫なしには異種のプログラミング言語間でデータを交換することはできない。

これに対して本研究では、データの中に型情報を格納することで、IDL無しでオブジェクトをデシリアライズすることを可能にする。また、多言語間でデータを交換することを可能にする。


\section{SunRPC}
SunRPC\cite{rfc5531}は、RPC(Remote Procedure Call)システムの１つである。SunRPCはシリアライズの方式としてXDRを用いる。

SunRPCでは、XDRによる構造体の定義と共に、RPCのインタフェースを記述する。文字列と整数を含んだ構造体を送受信するプログラムを記述する例を次に示す。

\begin{lstlisting}
struct echo_message {
    string str;
    int num;
};

program ECHO_PROG {
    version ECHO_VERSION {
        echo_message echo(echo_message) = 1;
    } = 1;
} = 0x20001001;
\end{lstlisting}

programセクションの中にRPCのインタフェースを記述している。echo\_message echo(echo\_message) = 1; では、RPCによって呼び出すことができる関数のインタフェースを定義している。

SunRPCは、やりとりするデータの型に関する情報を交換する方法を提供しない。このため、サーバ・クライアントの双方が同じインタフェース定義を事前に共有しておかなければならず、同じインタフェース定義を共有していなければ、データを交換することができない。

本研究では、動的型付けオブジェクトを利用することによって、インタフェース定義を事前に共有することなくデータを交換することを可能にする。

プログラムの更新と共にインタフェースの更新が必要になることは少なくないが、SunRPCではインタフェース定義が更新されることを想定しており、RPCのメッセージの中にバージョン番号を埋め込むことができる。クライアントとサーバのインタフェース定義のバージョンが異なれば、RPCは正しく失敗する。
% このような場合にすべてのクライアント・サーバでまったく同じIDLを共有し続けることは難しいが、

一方本研究では、交換されるオブジェクトの型情報を利用したプログラミングを可能にすることによって、異なるバージョンのプログラムでも正しくメッセージを交換できるようにする。


\section{JSON}
JSON\cite{rfc4506}は、オブジェクトシリアライズ手法の一つである。テキスト形式を用いるため、空間効率および処理速度は劣る。

JSONはXDRとは異なり、IDLを必要としない。オブジェクトをシリアライズする際に、型に関する情報を同時に格納することで、IDLを参照せずにオブジェクトをデシリアライズすることを可能にしている。

また、JSONは数多くの言語で実装されており、異種の言語間でオブジェクトを交換するために使用することができる。

一方、IDLを使用しないことから、デシリアライズされたオブジェクトの型は実行時に初めて決定することになるが、C++やJavaなどの静的型付け言語では、そのような動的型付けオブジェクトは扱いにくい。このため、デシリアライズされたオブジェクトを静的な型に変換するために、冗長なプログラミングが多く必要になるという欠点がある。

本研究では、動的型付けオブジェクトを静的に宣言された型に変換するAPIを実装することによって、静的型付け言語においても安全かつ高速にデシリアライズされたオブジェクトを扱えるようにする。


\section{Thrift}
Thrift\cite{ThriftURL}は、RPCシステムの一つである。バイナリ形式を用いるため、空間効率および処理速度に優れる。
大規模SNS(Social Network Service)サービス事業者のFacebookによって開発され、Facebookで利用されている。

Thriftを利用するには、SunRPCと同様に、専用のIDLを使ってRPCのインタフェースを記述しなければならない。このIDLを使用して、文字列と整数を含んだメッセージを送受信するインタフェースを定義する例を次に示す。

\begin{lstlisting}
struct EchoMessage {
    2:string str
    1:i32 num,
}

service EchoServer {
    EchoMessage echo(1: EchoMessage msg)
}
\end{lstlisting}

struct EchoMessageは、送受信するメッセージを表すデータ構造を定義している。EchoMessage echo(1: EchoMessage msg) では、RPCを使って呼び出すことができる関数のインタフェースを定義している。%構造体のフィールドやRPCの引数には、1:や2:などのように一意な数値を付与しなければならない。

ThriftはSunRPCとは異なり、メッセージの中にバージョン番号を埋め込むことができない。このためクライアントとサーバで異なるバージョンのIDLを使用していた場合に、それが必ずしも正しく検出されるとは限らない。このため転送されたデータが誤った形でデシリアライズしてしまう恐れがある。

この問題に対して、Thriftでは安全にIDLを更新できる方法を制限している。すなわち、構造体のフィールドに付与する一意な数値を更新してはならない。Thriftを利用する開発者がこの制限に従っている限りは、正しくオブジェクトを交換することができる。

本研究では、IDLを使用して型を静的に解決する代わりに、交換されるオブジェクトの型情報を利用したプログラミングを可能にすることによって、異なるバージョンのプログラムでも正しくメッセージを交換できるようにする。


\section{Protocol Buffers}
Protocol Buffersは、RPCシステムの一つである\cite{protobuf}。オブジェクトシリアライズ手法にはバイナリ形式を用いるため、空間効率および処理速度に優れる。
Googleが開発し、大規模なシステムで実際的に利用されている。
Protocol Buffersはいくつかのプログラミング言語で実装されており、異種の言語をまたいでオブジェクトをやりとりすることができる。

%Protocol Buffersは、Googleが開発し、大規模なシステムで実際的に利用されているシリアライズ形式である\cite{protobuf}。整数のシリアライズにはBase 128 VariantsとZigZag Encodingと呼ばれる手法が用いられており、小さい整数ほど少ないバイト数でシリアライズできる。Protocol Buffersは長いバイト列をシリアライズ/デシリアライズする際にコピーするため、負荷が高い。また整数を含むオブジェクトをシリアライズしたデータのサイズは、特に0から127までの小さい整数では、MessagePackより大きくなる。
%これはMessagePackはバイト列をコピーせずに扱える特徴を持つためである。またProtocol Buffersは整数のシリアライズにBase 128 VariantsとZigZag Encodingを利用しており、小さい整数をより小さく高速にシリアライズできる。MessagePackと比べてサイズは大きくなるが、高速である。
Protocol Buffersを利用するには、専用のIDLを使って定義を記述しなければならない。このIDLを使って、文字列と整数を含んだメッセージを記述する例を次に示す。

\begin{lstlisting}
package proto_protobuf;
option optimize_for = SPEED;

message EchoMessage {
    required string str = 1;
    required  int32 num = 2;
}
\end{lstlisting}

message EchoMessageは、RPCによって呼び出すことができる関数のインタフェースを定義している。この関数はstrとnumという2つの引数を受け取る。strの型は文字列であり、numの型は32ビットの符号付き整数である。

本研究では、IDLを使用せずに異種のプログラミング言語間・異種のサーバ間・異種のバージョン間でメッセージを交換することを可能にする。


\section{Avro}
Avro\cite{AvroURL}は、RPCシステムの一つである。オブジェクトシリアライズ手法にはバイナリ形式を用いる。%シリアライズ後のデータサイズは非常に小さく、処理速度も比較的高速である。
AvroはXDRやThritなどと同様にIDLを記述しなければならないが、交換するデータの先頭にIDLを付与することで、必ずしも事前に共有する必要が無いようにしている。

%IDLを事前に共有しない場合は、オブジェクトは動的型付けオブジェクトとしてデシリアライズされる。事前に共有する場合は、静的な型に自動的に変換される。このため静的型付け言語でも動的型付け言語でも扱いやすい。

XDRやProtocol Buffersでは、事前に共有されているIDLからプログラムを生成する方法を採っているため、IDLを解析・評価する処理系は1度実装すれば多数の言語に対応できる。しかしAvroでは、交換されるデータの先頭にIDLが付与されている場合に対応するために、すべての言語でIDLの処理系を実装しなければならない。このため多言語への実装の移植が難しいという欠点がある。Avroはこの実装コストの問題をある程度軽減するために、IDLの表現にJSONを用いているが、JSONはテキスト形式であり効率は劣る。

Avroは異種の言語をまたいで利用することを想定したシステムであるが、現時点で利用できる言語はC、JavaおよびPythonの3種類のみである。

本研究では、最低限利用可能な仕様をシンプルにすることによって実装を簡略化し、より多くの言語で利用できるようにする。同時に、発展的な機能として動的に型付けられたオブジェクトを静的に宣言された型に変換するAPIを提供することにより、IDLを使用とせずとも高速にメッセージを扱えるようにする。


\section{JavaRMI}
Java RMI(Remote Method Invocation)\cite{JavaRMI}は、ネットワークをまたいでオブジェクトのメソッド呼び出しができるようにすることを目的とした、Javaのライブラリである。
% TODO 型変換の話

Java RMIは、Javaでしか利用できない。本研究では、複数のプログラミング言語を横断してオブジェクトを交換できるようにする。


\section{CORBA}
CORBA(Common Object Request Broker Architecture)は、OMG(Object Management Group)によって仕様が定められている分散オブジェクト技術である。CORBAは、異なるプログラミング言語で構成された分散環境で動作するシステムを実装するための機能を提供している。しかし、APIが必要以上に複雑であるという問題が指摘されている\cite{corbaFall}。
% TODO 型変換の話

本研究では、実装を容易にして多言語対応を容易にするために、その設計をシンプルに抑えた。また、複雑な機能は必ずしも実装しなくても利用できるようにし、段階的な拡張が可能な設計とした。

\section{既存のメッセージ交換手法の課題}

既存のメッセージ交換手法には、次のような課題がある：

\begin{description}
\item [異種のプログラミング言語をまたいで利用できない]
XDR、SunRPC、JavaRMI
\item [静的型検査の仕組みを持たない]
JSON
\item [IDLを事前に共有しておかなければならない]
Thrift、Protocol Buffers
\item [複雑で実装が難しい]
CORBA、Avro
\item [空間効率と処理速度が低い]
JSON、Avro
\end{description}

MessagePackでは、これらの課題を解決する。

