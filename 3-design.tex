
\chapter{MessagePackのモデルと設計}
本章では、本研究で実装したシリアライズ形式であるMessagePackの設計について述べる。
第1節では、MessagePackで解決するメッセージ交換手法の課題を述べる。
第2節では、課題を解決するためモデルについて述べる。
第3節では、MessagePackの型システムについて述べる。
最後に第4節では、MessagePack表現形式について述べる。


%\section{設計の方針}
%MessagePackは、次のような方針で設計を行った。
%\begin{description}
%\item [多言語対応と共通部分の切り出し]
%どのプログラミング言語向けの実装でも利用するコードは、共通して利用できるようにする。これによって、多くの言語に対応するための実装の手間を軽減させる。
%%\item [データサイズの削減]
%%ネットワークを通じてメッセージを交換する際の負荷を小さくするために、メッセージをシリアライズした後のデータサイズは小さくなるようにする。ネットワークを越えてやりとりするデータのサイズを小さくすることで、ネットワーク処理にかかるCPUへの負荷を軽減することができる。
%\item [実行速度を重視した実装]
%実装を行う際に、保守性と実行速度がトレードオフになるような場面があった場合は、実行速度を重視する。このような場面の例には、敢えて実装詳細を隠蔽せずにコンパイラが関数のインライン化を行えるようにしたり、モジュール間の結合性を疎にするために参照を経由してアクセスさせるのをやめ、結合性を密にして直接的にアクセスできるようにするような場合がある。
%\item [マルチスレッド対応]
%MessagePackを利用するプログラムは、マルチスレッドで動作していることを前提とする。
%\item [プログラムの修正と互換性の維持]
%MessagePackを利用するプログラムを修正しても、MessagePackでシリアライズされたデータの互換性は保たれるようにする。
%これにより、機能の追加や最適化などのプログラムの改善を妨げないようにする。
%\end{description}


\section{メッセージ交換手法の課題}

まず、異種の言語をまたいでメッセージを交換することを可能にするには、それぞれの言語で提供されている型システムを相互に変換しなければならない。
例えば、C++では文字列とバイト列は区別されないが、JavaやRubyでは区別される。同じRubyにおいても、バージョン1.8にでは文字列とバイト列は区別されなかった。また、Javaでは多倍長整数型や日付型が標準ライブラリとして提供されるが、C++では提供されない。
このように、プログラミング言語によって型システムはまったく異なるため、あらゆる言語に完全に適合する型システムを設計することは難しい。%従って、これらの型システムを相互に変換する必要になる。

また、シリアライズされたデータからオブジェクトをデシリアライズして復元するには、元のオブジェクトの型に関する情報が必要になる。この型情報を、シリアライズ結果のデータの中に埋め込む方法を採用すると、データのサイズが肥大化してしまう問題がある。一方で、別の場所に格納する方法、すなわちIDL(インタフェース定義言語)を使用する方法を採用すると、離れたプログラムの間でIDLを事前に共有しておく方法を用意しなければならない。ソフトウェアが日々更新されていく中で、データとIDLのバージョンを常に一致させておくことは難しい。


\section{MessagePackの型変換モデル}

前節で述べた問題とトレードオフを解決するために、MessagePackは次のような設計とした：

\begin{itemize}
\item どのプログラミング言語にも依存しない、中立的な型システムを定義し、この型システムとプログラミング言語の型システムを相互に変換する仕組みを実装することで、多数のプログラミング言語を横断してメッセージを交換することを可能にする
\item 型情報をシリアライズ後のデータの中に格納するが、ハフマン符号化\cite{huffman}に見られるように、想定される使用頻度に応じてビットを割り当てることにより、型に関する情報をコンパクトに格納することを可能にする
\end{itemize}

MessagePackでは、どのプログラミング言語にも依存しないデータ型の集合を扱う。この中立的なデータ型の集合を{\bf MessagePackの型システム}と呼ぶ。
また、それらのデータ型をバイナリ列に変換して表現できるようにする。このMessagePackの型システムのバイナリ列における表現形式を{\bf MessagePackの表現形式}と呼ぶ。
MessagePackは、中立的なMessagePackの型システムと、バイナリ形式での表現形式および各言語の型システムを相互に変換することによって、多言語間のメッセージ交換を可能にする。このモデルを図\ref{figure2-model}に示す。

\begin{figure}[]
\begin{center}
\includegraphics[scale=0.7]{figure2-model.eps}
\caption{MessagePackの型変換モデル\label{figure2-model}}
\end{center}
\end{figure}


\section{型システムの設計}

JSONはRFC 4627\cite{rfc4627}で標準化されたシリアライズ形式であり、Webシステムを中心に幅広く利用されている。JSONの型システムは多くの開発者が習熟しているものである。そこでMessagePackの型システムで扱うデータ型は、JSONで扱うデータ型とほぼ同じになるようにした。これによって、新たな型システムを習熟しなければならないコストを低減する。

MessagePackの型システムで扱う7種類のデータ型を次に示す。

\begin{description}
\item [Nil]
Nilは、値がないことを表す。
\item [Boolean]
Booleanは、真偽値を示す型である。TrueまたはFalseを表す。
\item [Integer]
Integerは、整数を示す型である。64ビットの符号付き整数で表せる最小値（つまり-9,223,372,036,854,775,808）から、64ビットの符号無し整数で表せる最大値（つまり1,844,674,407,370,955,1615）までの整数を表す。
\item [Float]
Floatは、浮動小数を表す型である。IEEE 754\cite{IEE754}で定義された単精度二進化浮動小数点数または倍精度二進化浮動小数点数で表せる数を表す。
\item [Raw]
Rawは、バイト列を表す型である。
\item [Array]
Arrayは、配列を表す型である。%配列の要素には、任意の型のオブジェクトを含めることができる。
\item [Map]
Mapは、連想配列を表す型である。%連想配列のキーや値の要素には、任意の型のオブジェクトを含めることができる。
\end{description}

%文字列はRaw型を使って表す。MessagePackでは文字コードの変換は行わない。文字コードはMessagePackの利用者が規定するが、原則としてはJSONと同様にUTF-8に統一する。
%これらの型は、多くのプログラミング言語で利用できる型と同じものを選んだ。プログラミング言語にMessagePackの型と同じもの存在すれば、型に変換するプログラムの実装を省略することができる。
%MessagePackの型は、多くのプログラミング言語で利用できる型と相互に変換できることを目的としている。これによってインピーダンスミスマッチを回避する。そのために、これらの型は、考えられる多様な型の中から、多くのプログラミング言語で利用できる主要な型を選択するようにした。特定の言語でしか利用できないような型は、省略するようにした。

%各言語での実装では、これらの型と言語の型を相互に変換する仕組みを実装する。

これらのデータ型は、ほとんどの言語で利用することができるプリミティブなデータ型である。
データ型の種類を少なくすることにより、実装の難易度が下がるため、移植性が向上し、結果として多言語対応が容易になるという利点が得られる。

プログラミング言語によっては日付型や多倍長整数型のような型を提供しているが、そのような型は上記のMessagePack型に射影してシリアライズを行う。このような発展的な型に対する射影関数の導入については、4章で後述する。%型変換テンプレートによって容易に行えるようにした。


%このような型変換方法の拡張を容易に行えるようにする仕組みについては、4章で後述する。

%4章で後述する型変換テンプレートを使用して型システムの射影関数を導入することで、APIとしては透過的に利用できるようにした。
%これらの型とプログラミング言語の型の相互変換については、

%例えばRubyでは、Nil型をNilClass、Boolean型をTrueClassとFalseClass、Float型をFloat、Raw型をString、Array型をArray、Map型をHashクラスと相互に変換する。


%JSONで扱うデータ型とMessagePackで扱うデータ型は、JSONでは整数値型や浮動小数点数型に値の上限や下限が定められていない点が異なる。MessagePackで表せる範囲内では、JSONで表されたデータをMessagePackで表すように置き換えることができる。
%正確にはJSONの型はMessagePackの型のスーパーセットである。極めて大きい整数だけである。
%大半のJSONのオブジェクトは、MessagePackの型に変換することができる。

% TODO どこにいれる？また、既にJSONを使って書かれたプログラムをMessagePackを使うように書き換えることは容易である。JSONを使っているが性能が不足しているプログラムがあるとき、単にJSONをMessagePackに置き換えることで、性能を向上させることが可能になる。


\section{表現形式の設計}

\subsection{型情報の格納}
MessagePackの表現形式では、シリアライズ後のデータの中に、オブジェクトの型を表す情報を格納する。型情報を格納することで、事前にIDLを共有しておくことなくオブジェクトを交換することが可能になる。

また、データの中にオブジェクトの型を表す情報が格納されていると、プログラムが想定していない型のデータを受け取った場合に、それを検出することができる。言い換えれば、データに冗長性を持たせることができる。これによって、誤って送られてきたデータや、破損したデータを検出することが可能になる。

さらに、プログラムが想定していないデータを受け取った場合でも、型からデータの意味をある程度推測することができる。このようにデータの意味を推測できると、間違ったデータを送信してしまうようなバグがあった場合に、どの部分のプログラムが原因で問題が起こっているかを突き止めるための手がかりが増える。これによって、メッセージを交換するプログラムのデバッグを容易にしている。
例えば、ネットワークアナライザであるwireshark\cite{wiresharkURL}を用いてパケットをスニッフィングし、得られたデータをデシリアライズして表示することが可能になった\cite{dissectorMessagePackURL}。実際に運用しているソフトウェアを改変したり再起動したりすることなく、やりとりされているデータの構造を可視化し、デバッグに役立てることができる。

\subsection{データサイズの削減}
前節で述べた利点の一方で、型情報を含めるとデータのサイズは増大してしまう。この問題を軽減するために、型情報をコンパクトに格納できるように表現形式を設計した。
ハフマン符号\cite{huffman}に見られるように、より多く出現すると想定される種類の値に対して、より多くのビットを割り当てる。これによってデータサイズを削減する。

MessagePackの表現形式では、先頭の1バイトの中でデータの型を表し、そのバイトまたはそれ以降のバイトで値を表す。先頭の1バイトは、次に示すように複数のグループに分類する。

\begin{lstlisting}
    表現形式          2進数表現      16進数表現
Fixnum
    Positive Fixnum    0xxxxxxx       00 - 7f
    Negative Fixnum    111xxxxx       e0 - ff

Category-1
    nil                11000000       c0
    (reserved)         11000001       c1
    false              11000010       c2
    true               11000011       c3

Category-2
    float              11001010       ca
    double             11001011       cb
    uint 8             11001100       cc
    uint 16            11001101       cd
    uint 32            11001110       ce
    uint 64            11001111       cf
    int 8              11010000       d0
    int 16             11010001       d1
    int 32             11010010       d2
    int 64             11010011       d3

Category-3
    raw 16             11011010       da
    raw 32             11011011       db
    array 16           11011100       dc
    array 32           11011101       dd
    map 16             11011110       de
    map 32             11011111       df

FixRaw
    FixRaw             101xxxxx       a0 - bf

FixArray
    FixArray           1001xxxx       90 - 9f

FixMap
    FixMap             1000xxxx       80 - 8f
\end{lstlisting}

それぞれのグループには、次のような規則性を設定した。

\begin{description}
\item [Fixnum]
このグループに属する表現形式は、オブジェクトの型と値が1バイトで表される。また、その1バイトがそのまま（Cではキャストするだけで）符号無し8ビット整数または符号付き8ビット整数の値になる。
\item [Category-1]
このグループに属する表現形式は、オブジェクトの型と値が1バイトで表される。
\item [Category-2]
このグループに属する表現形式は、オブジェクトの型と、後続するデータの長さが、1バイトで表される。 また、そのデータの長さは (1 {\footnotesize$<<$} (先頭バイト \& 0x03)) という計算式によって求められる。
\item [Category-3]
このグループに属する表現形式は、オブジェクトの型と、後続するオブジェクトの要素数を表すデータの長さが、1バイトで表される。また、そのオブジェクトの要素数を表すデータの長さは (2 {\footnotesize$<<$} (先頭バイト \& 0x01)) という計算式によって求められる。
\end{description}

一つのオブジェクトを表すために複数の表現形式を選択できる場合は、もっとも小さいサイズで表現できる表現形式を選択する。
例えば、整数1や整数2は、表現形式Positive Fixnumを使用して1バイトで表現する。このように、フラグやエラーコードなどの用途に頻繁に利用される小さい整数は、このようにごく少ないバイト数で表現することができる。
同様に、エラーメッセージの表現などで頻繁に利用される短い文字列や、構造体の表現に頻繁に使用される短い配列も、少ないバイト数で表現することができる。
一方、整数70000は、表現形式uint32を使用して5バイトで表現する。このように、使用される頻度が少ない大きなサイズのオブジェクトは、多くのバイト数を消費して表現する。

表現形式の一覧は付録に示す。

%MessagePackの実装では、
%MessagePackの実装では、表現するデータ型に対応する複数の表現形式の中から、もっとも小さいサイズでオブジェクトを表現できる表現形式を選択し、シリアライズを行う。

%型を表す情報を含めることで、データを扱うプログラムを少し変更しても、シリアライズ後のデータの互換性を損なわずに、そのデータを扱うプログラムを修正することを可能にする。

%例えば、3つの要素を含む配列を扱うプログラムがあるときに、配列の要素の数を4つに増やすようにプログラムを修正したとしても、修正するときに4つ目の要素が足りなければデフォルト値を使うようにするだけで、既存のシリアライズ済みのデータも扱うことができる。これによって、サーバープログラムを修正したり再起動したりせずに、クライアントプログラムを修正するようなことが可能になる。

%また、プログラムが想定していない型のデータを受け取ったときでも、型からデータの内容をある程度推測することができる。データの内容を推測できると、プログラムに間違ったデータを送信してしまうようなバグがあったときに、どこの部分のコードが原因で問題が起こっているかを突き止めるための手がかりが増える。これによって、メッセージを交換するプログラムのデバッグを容易にする。

%これに対して、シリアライズ後のデータにオブジェクトの型情報が含まれていると、未知のデータでもデシリアライズできるようになる。このため、サーバープログラムを修正したり再起動せずに、クライアントプログラムをバージョンアップするようなことが可能になる。

%シリアライズ後のデータに型を表すの情報が入っていないと、アプリケーションは型情報を何か別の手段を使って調べなければ、デシリアライズができない。また、未知のデータはデシリアライズできない。このため、オブジェクトをシリアライズするプログラムをバージョンアップするなどの理由で、オブジェクトのデータ型が少しでも変わったら、データをデシリアライズする側のプログラムも修正しなければならない。また、それがサーバープログラムであれば、再起動もしなければならない。

%これに対して、シリアライズ後のデータにオブジェクトの型情報が含まれていると、未知のデータでもデシリアライズできるようになる。このため、サーバープログラムを修正したり再起動せずに、クライアントプログラムをバージョンアップするようなことが可能になる。

%\section{表現形式の実装}
%
%\subsection{データサイズの削減}
%
%%シリアライズするオブジェクトに適した表現形式を選択することで、データサイズを削減できる。
%
%%このように複数の表現形式を用意することで、
%%1つのデータ型に対して複数の表現形式を用意し、シリアライズする値に適した表現形式を選択できるようにすることで、
%
%
%\subsection{実装しやすい表現形式の設計}
%MessagePackの表現形式では、先頭の1バイトの中でデータの型を表し、そのバイトまたはそれ以降のバイトで値を表す。
%
%先頭の1バイトは、次に示すように複数のグループに分類する。これらのグループに規則性を設定することで、シリアライザやデシリアライザの実装が容易になるようにした。

%
%%\section{データサイズ}
%%FIXME カット？
%%・小さな整数のサイズが特に小さい
%%・・Protocol Buffersと比較
%%・小さな配列のサイズが特に小さい
%%・・Protocol Buffersと比較
%
%%\subsection{全文検索エンジンでの利用}
%%FIXME カット？
%%・全文検索エンジンでは、posting listの送受信を頻繁に行う
%%・posting listは、整数を含んだ構造体を多数含む配列
%%・構造体は、配列で表現する
%%・つまり全文検索エンジンでは、（小さな？）整数を含んだ配列を多数含む配列を頻繁に送受信する
%%・整数のサイズや配列のサイズが効く
%
%%\section{長さの表現}
%%FIXME カット？
%%・MessagePackでは、必ずデータの先頭にそのデータの長さが入る
%%・他の方法：終端文字・終端データを入れる
%%・・文字列の終端を"で表現（JSON）
%%・・・論外。遅すぎる
%%・・・"をエスケープ・エスケープ解除する必要がある->コピーが発生->非常に遅い
%%・・・1文字1文字"であるかどうかチェックしていく必要がある->非常に遅い
%%・・配列の終端を特殊なデータで表現
%%・あらかじめコンテナのサイズを決定できる
%%・・データを受信しながら、コンテナのサイズを動的に増やしていく必要が無い：高速
%
%
